<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Mobile Mosaic – ROI Drag (POINTER FINAL)</title>

<style>
body{
  margin:0;
  background:#eee;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  min-height:100vh;
  font-family:sans-serif;
  touch-action:none;
  overscroll-behavior:none;
}

.wrapper{
  background:#fff;
  padding:20px;
  margin-top:20px;
  border-radius:12px;
  width:95%;
  max-width:950px;
  text-align:center;
  box-shadow:0 0 8px rgba(0,0,0,.15);
}

.canvas-wrap{
  position:relative;
  touch-action:none;
}

canvas{
  width:100%;
  border:1px solid #aaa;
  touch-action:none;
}

#overlay{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}
</style>
</head>

<body>
<div class="wrapper">
<h2>비식별화(모자이크)</h2>

<input type="file" id="upload" accept="image/*"><br><br>

모자이크 강도 :
<input type="range" id="rate" min="1" max="40" value="15">
<span id="rateValue">15</span><br><br>

<button onclick="saveImage()">저장</button>
<button onclick="undo()">Undo</button>
<button onclick="redo()">Redo</button>
<button onclick="resetImage()">처음으로</button>

<br><br>

<div class="canvas-wrap">
  <canvas id="canvas"></canvas>
  <canvas id="overlay"></canvas>
</div>
</div>

<script>
document.body.style.overflow = "hidden";

const canvas = document.getElementById("canvas");
const overlay = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const octx = overlay.getContext("2d");

const sourceCanvas = document.createElement("canvas");
const sctx = sourceCanvas.getContext("2d");

let img = new Image();
let blocks = [];
let undoStack = [];
let redoStack = [];
let rate = 15;

const rateSlider = document.getElementById("rate");
const rateValue = document.getElementById("rateValue");

let dragging = false;
let startX = 0, startY = 0;

// ===============================
document.getElementById("upload").onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
  img.onload = () => {
    canvas.width = overlay.width = sourceCanvas.width = img.width;
    canvas.height = overlay.height = sourceCanvas.height = img.height;

    ctx.drawImage(img,0,0);
    sctx.drawImage(img,0,0);

    blocks = [];
    undoStack = [];
    redoStack = [];
    pushUndo();
  };
};

// ===============================
rateSlider.oninput = () => {
  rate = +rateSlider.value;
  rateValue.innerText = rate;
  redraw();
};

// ===============================
function getPos(e){
  const r = canvas.getBoundingClientRect();
  return {
    x:(e.clientX - r.left) * (canvas.width / r.width),
    y:(e.clientY - r.top)  * (canvas.height / r.height)
  };
}

// ===============================
// POINTER EVENTS (PC + MOBILE 통합)
canvas.addEventListener("pointerdown", e=>{
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  dragging = true;
  const p = getPos(e);
  startX = p.x;
  startY = p.y;
});

canvas.addEventListener("pointermove", e=>{
  if(!dragging) return;
  const p = getPos(e);
  requestAnimationFrame(()=>{
    drawPreview(startX, startY, p.x, p.y);
  });
});

canvas.addEventListener("pointerup", e=>{
  if(!dragging) return;
  dragging = false;
  octx.clearRect(0,0,overlay.width,overlay.height);
  const p = getPos(e);
  addBlock(startX, startY, p.x, p.y);
});

canvas.addEventListener("pointercancel", ()=>{
  dragging = false;
  octx.clearRect(0,0,overlay.width,overlay.height);
});

// ===============================
function drawPreview(x1,y1,x2,y2){
  octx.clearRect(0,0,overlay.width,overlay.height);
  octx.setLineDash([6,4]);
  octx.lineWidth = 2;
  octx.strokeStyle = "rgba(0,0,255,.9)";
  octx.strokeRect(
    Math.min(x1,x2),
    Math.min(y1,y2),
    Math.abs(x2-x1),
    Math.abs(y2-y1)
  );
}

// ===============================
function addBlock(x1,y1,x2,y2){
  const w = Math.abs(x2-x1);
  const h = Math.abs(y2-y1);
  if(w < 5 || h < 5) return;

  blocks.push({
    left: Math.min(x1,x2),
    top:  Math.min(y1,y2),
    w, h
  });

  redoStack = [];
  redraw();
  pushUndo();
}

// ===============================
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(sourceCanvas,0,0);
  blocks.forEach(b => mosaic(b));
}

// ===============================
function mosaic(b){
  const t = document.createElement("canvas");
  t.width = b.w;
  t.height = b.h;
  const tctx = t.getContext("2d");

  tctx.drawImage(
    sourceCanvas,
    b.left, b.top, b.w, b.h,
    0, 0, b.w, b.h
  );

  for(let x=0; x<b.w; x+=rate){
    for(let y=0; y<b.h; y+=rate){
      const d = tctx.getImageData(x,y,1,1).data;
      tctx.fillStyle = `rgb(${d[0]},${d[1]},${d[2]})`;
      tctx.fillRect(x,y,rate,rate);
    }
  }
  ctx.drawImage(t, b.left, b.top);
}

// ===============================
function pushUndo(){
  undoStack.push(JSON.parse(JSON.stringify(blocks)));
}

function undo(){
  if(undoStack.length < 2) return;
  redoStack.push(undoStack.pop());
  blocks = JSON.parse(JSON.stringify(undoStack.at(-1)));
  redraw();
}

function redo(){
  if(!redoStack.length) return;
  const s = redoStack.pop();
  undoStack.push(s);
  blocks = JSON.parse(JSON.stringify(s));
  redraw();
}

function resetImage(){
  blocks = [];
  redoStack = [];
  redraw();
  undoStack = [];
  pushUndo();
}

function saveImage(){
  const a = document.createElement("a");
  a.href = canvas.toDataURL();
  a.download = "mosaic.png";
  a.click();
}
</script>
</body>
</html>
