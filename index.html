<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Mobile Mosaic – ROI Drag Pro</title>

<style>
body{
  margin:0;
  background:#eee;
  display:flex;
  justify-content:center;
  align-items:flex-start;
  min-height:100vh;
  font-family:sans-serif;
}
.wrapper{
  background:#fff;
  padding:16px;
  margin:10px;
  border-radius:12px;
  width:100%;
  max-width:950px;
  text-align:center;
  box-shadow:0 0 8px rgba(0,0,0,.15);
}
.canvas-wrap{
  position:relative;
  width:100%;
}
canvas{
  width:100%;
  display:block;
  border:1px solid #aaa;
  touch-action:none;
}
#overlay{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}
button{margin:4px;}
</style>
</head>

<body>
<div class="wrapper">
<h2>비식별화(모자이크)</h2>

<input type="file" id="upload" accept="image/*"><br><br>

모자이크 강도 :
<input type="range" id="rate" min="1" max="40" value="15">
<span id="rateValue">15</span><br><br>

<button onclick="saveImage()">저장</button>
<button onclick="undo()">Undo</button>
<button onclick="redo()">Redo</button>
<button onclick="resetImage()">처음으로</button>

<br><br>

<div class="canvas-wrap">
  <canvas id="canvas"></canvas>
  <canvas id="overlay"></canvas>
</div>
</div>

<script>
const canvas = document.getElementById("canvas");
const overlay = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const octx = overlay.getContext("2d");

const sourceCanvas = document.createElement("canvas");
const sctx = sourceCanvas.getContext("2d");

let img = new Image();
let blocks = [];
let undoStack = [];
let redoStack = [];
let rate = 15;

const dpr = window.devicePixelRatio || 1;
const isMobile = window.matchMedia("(pointer: coarse)").matches;

function effectiveRate(){
  return isMobile ? rate * 2 : rate;
}

const rateSlider = document.getElementById("rate");
const rateValue = document.getElementById("rateValue");

let dragging=false,startX=0,startY=0;

// ===============================
document.getElementById("upload").onchange=e=>{
  img.src = URL.createObjectURL(e.target.files[0]);
  img.onload=()=>{
    const displayWidth = canvas.parentElement.clientWidth;
    const scale = displayWidth / img.width;

    const w = img.width * scale;
    const h = img.height * scale;

    canvas.style.width = overlay.style.width = w + "px";
    canvas.style.height = overlay.style.height = h + "px";

    canvas.width = overlay.width = w * dpr;
    canvas.height = overlay.height = h * dpr;

    sourceCanvas.width = img.width;
    sourceCanvas.height = img.height;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    octx.setTransform(dpr,0,0,dpr,0,0);

    ctx.drawImage(img,0,0,w,h);
    sctx.drawImage(img,0,0);

    blocks=[];
    undoStack=[];
    redoStack=[];
    pushUndo();
  };
};

// ===============================
rateSlider.oninput=()=>{
  rate=+rateSlider.value;
  rateValue.innerText=rate;
  redraw();
};

// ===============================
function getPos(e){
  const r=canvas.getBoundingClientRect();
  return {
    x:(e.clientX-r.left)*(canvas.width/dpr/r.width),
    y:(e.clientY-r.top)*(canvas.height/dpr/r.height)
  };
}

// ===============================
canvas.addEventListener("pointerdown",e=>{
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  dragging=true;
  const p=getPos(e);
  startX=p.x; startY=p.y;
});

canvas.addEventListener("pointermove",e=>{
  if(!dragging) return;
  const p=getPos(e);
  drawPreview(startX,startY,p.x,p.y);
});

canvas.addEventListener("pointerup",e=>{
  if(!dragging) return;
  dragging=false;
  canvas.releasePointerCapture(e.pointerId);
  octx.clearRect(0,0,overlay.width,overlay.height);
  const p=getPos(e);
  addBlock(startX,startY,p.x,p.y);
});

canvas.addEventListener("pointercancel",()=>{
  dragging=false;
  octx.clearRect(0,0,overlay.width,overlay.height);
});

// ===============================
function drawPreview(x1,y1,x2,y2){
  octx.clearRect(0,0,overlay.width,overlay.height);
  octx.setLineDash([6,4]);
  octx.lineWidth = 2;
  octx.strokeStyle="rgba(0,120,255,0.9)";
  octx.strokeRect(
    Math.min(x1,x2),
    Math.min(y1,y2),
    Math.abs(x2-x1),
    Math.abs(y2-y1)
  );
}

// ===============================
function addBlock(x1,y1,x2,y2){
  let w=Math.abs(x2-x1), h=Math.abs(y2-y1);
  if(w<5||h<5) return;

  blocks.push({
    left:Math.min(x1,x2),
    top:Math.min(y1,y2),
    w,h
  });

  redoStack=[];
  redraw();
  pushUndo();
}

// ===============================
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(canvas,0,0);
  ctx.drawImage(canvas,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img,0,0,canvas.width/dpr,canvas.height/dpr);
  blocks.forEach(b=>mosaic(b));
}

// ===============================
function mosaic(b){
  let t=document.createElement("canvas");
  t.width=b.w; t.height=b.h;
  let tctx=t.getContext("2d");

  tctx.drawImage(
    sourceCanvas,
    b.left, b.top, b.w, b.h,
    0, 0, b.w, b.h
  );

  const r = effectiveRate();

  for(let x=0;x<b.w;x+=r){
    for(let y=0;y<b.h;y+=r){
      let d=tctx.getImageData(x,y,1,1).data;
      tctx.fillStyle=`rgb(${d[0]},${d[1]},${d[2]})`;
      tctx.fillRect(x,y,r,r);
    }
  }
  ctx.drawImage(t,b.left,b.top,b.w,b.h);
}

// ===============================
function pushUndo(){
  undoStack.push(JSON.parse(JSON.stringify(blocks)));
}

function undo(){
  if(undoStack.length<2) return;
  redoStack.push(undoStack.pop());
  blocks=JSON.parse(JSON.stringify(undoStack.at(-1)));
  redraw();
}

function redo(){
  if(!redoStack.length) return;
  let s=redoStack.pop();
  undoStack.push(s);
  blocks=JSON.parse(JSON.stringify(s));
  redraw();
}

function resetImage(){
  blocks=[];
  redoStack=[];
  undoStack=[];
  redraw();
  pushUndo();
}

function saveImage(){
  let a=document.createElement("a");
  a.href=canvas.toDataURL();
  a.download="mosaic.png";
  a.click();
}
</script>
</body>
</html>
